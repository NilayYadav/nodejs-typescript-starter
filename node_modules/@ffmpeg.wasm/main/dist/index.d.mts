declare namespace Emscripten {
    interface FileSystemType {
    }
    type EnvironmentType = "WEB" | "NODE" | "SHELL" | "WORKER";
    type JSType = "number" | "string" | "array" | "boolean";
    type TypeCompatibleWithC = number | string | any[] | boolean;
    type CIntType = "i8" | "i16" | "i32" | "i64";
    type CFloatType = "float" | "double";
    type CPointerType = "i8*" | "i16*" | "i32*" | "i64*" | "float*" | "double*" | "*";
    type CType = CIntType | CFloatType | CPointerType;
    type WebAssemblyImports = Array<{
        name: string;
        kind: string;
    }>;
    type WebAssemblyExports = Array<{
        module: string;
        name: string;
        kind: string;
    }>;
    interface CCallOpts {
        async?: boolean | undefined;
    }
    type Module<R extends keyof RuntimeMethods = never> = Pick<RuntimeMethods, R> & ModuleMethods;
    interface ModuleMethods {
        print(str: string): void;
        printErr(str: string): void;
        arguments: string[];
        environment: Emscripten.EnvironmentType;
        preInit: Array<{
            (): void;
        }>;
        preRun: Array<{
            (): void;
        }>;
        postRun: Array<{
            (): void;
        }>;
        onAbort: {
            (what: any): void;
        };
        onRuntimeInitialized: {
            (): void;
        };
        preinitializedWebGLContext: WebGLRenderingContext;
        noInitialRun: boolean;
        noExitRuntime: boolean;
        logReadFiles: boolean;
        filePackagePrefixURL: string;
        wasmBinary: ArrayBuffer;
        destroy(object: object): void;
        getPreloadedPackage(remotePackageName: string, remotePackageSize: number): ArrayBuffer;
        instantiateWasm(imports: Emscripten.WebAssemblyImports, successCallback: (module: WebAssembly.Module) => void): Emscripten.WebAssemblyExports;
        locateFile(url: string, scriptDirectory: string): string;
        onCustomMessage(event: MessageEvent): void;
        HEAP: Int32Array;
        IHEAP: Int32Array;
        FHEAP: Float64Array;
        HEAP8: Int8Array;
        HEAP16: Int16Array;
        HEAP32: Int32Array;
        HEAPU8: Uint8Array;
        HEAPU16: Uint16Array;
        HEAPU32: Uint32Array;
        HEAPF32: Float32Array;
        HEAPF64: Float64Array;
        HEAP64: BigInt64Array;
        HEAPU64: BigUint64Array;
        TOTAL_STACK: number;
        TOTAL_MEMORY: number;
        FAST_MEMORY: number;
        addOnPreRun(cb: () => void): void;
        addOnInit(cb: () => void): void;
        addOnPreMain(cb: () => void): void;
        addOnExit(cb: () => void): void;
        addOnPostRun(cb: () => void): void;
        preloadedImages: any;
        preloadedAudios: any;
        _malloc(size: number): number;
        _free(ptr: number): void;
    }
    type ModuleFactory<T extends Emscripten.Module = Emscripten.Module> = (moduleOverrides?: Partial<T>) => Promise<T>;
    namespace FileSystem {
        interface Stats {
            dev: number;
            ino: number;
            mode: number;
            nlink: number;
            uid: number;
            gid: number;
            rdev: number;
            size: number;
            blksize: number;
            blocks: number;
            atime: Date;
            mtime: Date;
            ctime: Date;
            birthtime: Date;
        }
        interface FSStream {
        }
        interface FSNode {
        }
        interface ErrnoError {
        }
        interface FS {
            lookupPath(path: string, opts?: {
                parent: boolean;
                follow: boolean;
            }): {
                path: string;
                node: FSNode;
            };
            getPath(node: FSNode): string;
            isFile(mode: number): boolean;
            isDir(mode: number): boolean;
            isLink(mode: number): boolean;
            isChrdev(mode: number): boolean;
            isBlkdev(mode: number): boolean;
            isFIFO(mode: number): boolean;
            isSocket(mode: number): boolean;
            major(dev: number): number;
            minor(dev: number): number;
            makede(ma: number, mi: number): number;
            registerDevice(dev: number, ops: any): void;
            syncfs(populate: boolean, callback: (e?: unknown) => void): void;
            syncfs(callback: (e?: unknown) => void, populate?: boolean): void;
            mount(type: Emscripten.FileSystemType, opts: object, mountpoint: string): void;
            unmount(mountpoint: string): void;
            mkdir(path: string, mode?: number): void;
            mkdev(path: string, mode?: number, dev?: number): void;
            symlink(oldpath: string, newpath: string): void;
            rename(old_path: string, new_path: string): void;
            rmdir(path: string): void;
            readdir(path: string): string[];
            unlink(path: string): void;
            readlink(path: string): string;
            stat(path: string, dontFollow?: boolean): Stats;
            lstat(path: string): Stats;
            chmod(path: string, mode: number, dontFollow?: boolean): void;
            lchmod(path: string, mode: number): void;
            fchmod(fd: number, mode: number): void;
            chown(path: string, uid: number, gid: number, dontFollow?: boolean): void;
            lchown(path: string, uid: number, gid: number): void;
            fchown(fd: number, uid: number, gid: number): void;
            truncate(path: string, len: number): void;
            ftruncate(fd: number, len: number): void;
            utime(path: string, atime: number, mtime: number): void;
            open(path: string, flags: string, mode?: number, fd_start?: number, fd_end?: number): FSStream;
            close(stream: FSStream): void;
            llseek(stream: FSStream, offset: number, whence: number): void;
            read(stream: FSStream, buffer: ArrayBufferView, offset: number, length: number, position?: number): number;
            write(stream: FSStream, buffer: ArrayBufferView, offset: number, length: number, position?: number, canOwn?: boolean): number;
            allocate(stream: FSStream, offset: number, length: number): void;
            mmap(stream: FSStream, buffer: ArrayBufferView, offset: number, length: number, position: number, prot: number, flags: number): any;
            ioctl(stream: FSStream, cmd: any, arg: any): any;
            readFile(path: string, opts: {
                encoding: "binary";
                flags?: string | undefined;
            }): Uint8Array;
            readFile(path: string, opts: {
                encoding: "utf8";
                flags?: string | undefined;
            }): string;
            readFile(path: string, opts?: {
                flags?: string | undefined;
            }): Uint8Array;
            writeFile(path: string, data: string | ArrayBufferView, opts?: {
                flags?: string | undefined;
            }): void;
            cwd(): string;
            chdir(path: string): void;
            init(input: (() => number | null) | null, output: ((c: number | null) => void) | null, error: ((c: number | null) => void) | null): void;
            createLazyFile(parent: string | FSNode, name: string, url: string, canRead: boolean, canWrite: boolean): FSNode;
            createPreloadedFile(parent: string | FSNode, name: string, url: string, canRead: boolean, canWrite: boolean, onload?: () => void, onerror?: () => void, dontCreateFile?: boolean, canOwn?: boolean): void;
            createDataFile(parent: string | FSNode, name: string, data: ArrayBufferView, canRead: boolean, canWrite: boolean, canOwn: boolean): FSNode;
        }
    }
    type StringToType<R> = R extends Emscripten.JSType ? {
        number: number;
        string: string;
        array: number[] | string[] | boolean[] | Uint8Array | Int8Array;
        boolean: boolean;
        null: null;
    }[R] : never;
    type ArgsToType<T extends Array<Emscripten.JSType | null>> = Extract<{
        [P in keyof T]: StringToType<T[P]>;
    }, any[]>;
    type ReturnToType<R extends Emscripten.JSType | null> = R extends null ? null : StringToType<Exclude<R, null>>;
    interface RuntimeMethods {
        cwrap<I extends Array<Emscripten.JSType | null> | [], R extends Emscripten.JSType | null>(ident: string, returnType: R, argTypes: I, opts?: Emscripten.CCallOpts): (...arg: Emscripten.ArgsToType<I>) => Emscripten.ReturnToType<R>;
        ccall<I extends Array<Emscripten.JSType | null> | [], R extends Emscripten.JSType | null>(ident: string, returnType: R, argTypes: I, args: ArgsToType<I>, opts?: Emscripten.CCallOpts): Emscripten.ReturnToType<R>;
        setValue(ptr: number, value: any, type: Emscripten.CType, noSafe?: boolean): void;
        getValue(ptr: number, type: Emscripten.CType, noSafe?: boolean): number;
        allocate(slab: number[] | ArrayBufferView | number, types: Emscripten.CType | Emscripten.CType[], allocator: number, ptr?: number): number;
        stackAlloc(size: number): number;
        tackSave(): number;
        tackRestore(ptr: number): void;
        UTF8ToString(ptr: number, maxBytesToRead?: number): string;
        stringToUTF8(str: string, outPtr: number, maxBytesToRead?: number): void;
        lengthBytesUTF8(str: string): number;
        allocateUTF8(str: string): number;
        allocateUTF8OnStack(str: string): number;
        UTF16ToString(ptr: number): string;
        stringToUTF16(str: string, outPtr: number, maxBytesToRead?: number): void;
        lengthBytesUTF16(str: string): number;
        UTF32ToString(ptr: number): string;
        stringToUTF32(str: string, outPtr: number, maxBytesToRead?: number): void;
        lengthBytesUTF32(str: string): number;
        intArrayFromString(stringy: string, dontAddNull?: boolean, length?: number): number[];
        intArrayToString(array: number[]): string;
        writeStringToMemory(str: string, buffer: number, dontAddNull: boolean): void;
        writeArrayToMemory(array: number[], buffer: number): void;
        writeAsciiToMemory(str: string, buffer: number, dontAddNull: boolean): void;
        addRunDependency(id: any): void;
        removeRunDependency(id: any): void;
        addFunction(func: (...args: any[]) => any, signature?: string): number;
        removeFunction(funcPtr: number): void;
        ALLOC_NORMAL: number;
        ALLOC_STACK: number;
        ALLOC_STATIC: number;
        ALLOC_DYNAMIC: number;
        ALLOC_NONE: number;
    }
}

type FFmpegCoreRuntimeMethods = "addFunction" | "ccall" | "cwrap" | "lengthBytesUTF8" | "setValue" | "stringToUTF8";
interface FFmpegCore extends Emscripten.Module<FFmpegCoreRuntimeMethods> {
    simd: boolean;
    thread: boolean;
    wasi: boolean;
    exit: () => boolean;
    FS: Emscripten.FileSystem.FS;
}
type FFmpegCoreConstructor = Emscripten.ModuleFactory<FFmpegCore>;

interface FFmpegFlags {
    simd: boolean;
    thread: boolean;
    wasi: boolean;
}

interface FFmpegVersion {
    core: FFmpegCoreVersion;
    main: string;
}
interface FFmpegCoreVersion {
    /** Version of FFmpeg core */
    version: string;
    /** Build params */
    configuration: string;
    /** Libraries version */
    libs: Record<string, string>;
    /** Raw result of $(ffmpeg -version) */
    raw: string;
}

type FFmpegLogger = (level: "debug" | "info" | "warn" | "error", ...msg: unknown[]) => void;
interface FFmpegInitOptions {
    core?: string | FFmpegCoreConstructor;
    coreOptions?: {
        locateFile?: Emscripten.Module["locateFile"];
        wasmPath?: string;
        workerPath?: string;
    };
    defaultArgs?: string[];
    log?: boolean;
    logger?: FFmpegLogger;
}

declare const importCore: (core: string | FFmpegCoreConstructor, logger: FFmpegLogger) => Promise<FFmpegCoreConstructor>;

declare const logError: (err: unknown, args: string[], logger: FFmpegLogger) => void;

declare function parseVersion(output: string): FFmpegCoreVersion;

/**
 * Write arguments to memory
 * @param core FFmpeg core
 * @param args array of arguments
 * @returns a pointer
 */
declare const writeArgs: (core: FFmpegCore, args: string[]) => number;

declare class FFmpeg {
    /**
     * Has the core exited
     * @readonly
     */
    get exited(): boolean;
    flags: FFmpegFlags;
    /** Memory file system API */
    fs: Emscripten.FileSystem.FS;
    /** Versions of FFmpeg.wasm */
    version: FFmpegVersion;
    protected core: FFmpegCore;
    protected _exited: boolean;
    protected exec: (argc: number, argv: number) => number;
    protected execAsync: (argc: number, argv: number, resolve: number, reject: number) => number;
    protected options: Required<FFmpegInitOptions>;
    protected tasks: Map<symbol, {
        promise: Promise<number>;
        reject: (reason: unknown) => void;
    }>;
    /**
     * Don't use this constructor direct, use FFmpeg.create() instead!
     * @see {@link create}
     * @param core FFmpeg.wasm core
     * @param options init options
     */
    private constructor();
    /**
     * Create a new FFmpeg instance
     * @param _options init options
     * @returns created instance
     */
    static create(_options?: FFmpegInitOptions): Promise<FFmpeg>;
    /**
     * Execute FFmpeg like CLI (stdin is not available)
     * @param _args array of parameters, same as CLI
     * @returns promise with exit code
     */
    run(..._args: string[]): Promise<number>;
    /**
     * Force FFmpeg to run synchronously (same behaviour as ffmpeg.run() in single-thread core)
     * @param _args array of parameters, same as CLI
     * @returns exit code
     */
    runSync(..._args: string[]): number;
    /**
     * Disable new tasks, if there are unfinished tasks:
     * `kill`  - terminate all ongoing tasks and exit
     * `break` - abort and return false if there are tasks in progress
     * `wait`  - wait for all ongoing tasks to be completed and then exit
     * @param handleInProgress Processing mode for ongoing tasks
     */
    exit(handleInProgress: "wait"): Promise<boolean>;
    exit(handleInProgress?: "break" | "kill"): boolean;
    setLogging(enbaled: boolean): void;
    /**
     * Replace logger
     * @param logger logger function
     */
    setLogger(logger: FFmpegLogger): void;
}

export { Emscripten, FFmpeg, FFmpegCore, FFmpegCoreConstructor, FFmpegCoreRuntimeMethods, FFmpegCoreVersion, FFmpegFlags, FFmpegVersion, importCore, logError, parseVersion, writeArgs };
